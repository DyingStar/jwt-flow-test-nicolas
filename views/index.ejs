<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Salesforce OAuth - Explained</title>
        <link href="css/bootstrap.min.css" rel="stylesheet" />
        <link href="css/index.css" rel="stylesheet" />

        <link rel="icon" type="image/icon" href="Cloud Red.ico" />

        <script type="text/javascript" src="lib/jquery.js"></script>
        <script type="text/javascript" src="lib/jqueryCookies.js"></script>
        <script type="text/javascript" src="lib/bootstrap.min.js"></script>
        <script type="text/javascript" src="js/index.js"></script>
    </head>

    <body class="container" style="padding-top: 50px" onload="onload()">
        <!-- Navigation pane on top of page -->
        <nav role="navigation" class="navbar navbar-default navbar-fixed-top navbar-inverse">
            <div class="container">
                <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                    <ul class="nav navbar-nav">
                        <li>
                            <a href="#divHome">Home</a>
                        </li>
                        <li>
                            <a href="#userAgentFlow">User Agent</a>
                        </li>
                        <li>
                            <a href="#webServer">Web Server</a>
                        </li>
                        <li>
                            <a href="#refreshToken">Refresh Token</a>
                        </li>
                        <li>
                            <a href="#jwt">JWT</a>
                        </li>
                        <li>
                            <a href="#samlBearerAssertion">SAML Bearer Assertion</a>
                        </li>
                        <li>
                            <a href="#samlAssertion">SAML Assertion</a>
                        </li>
                        <li>
                            <a href="#deviceFlow">Device Authentication Flow </a>
                        </li>
                        <li>
                            <a href="#usernamePassword">Username Password</a>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>

        <!-- Title and description -->
        <div class="jumbotron" Id="divHome">
            <h1>Salesforce OAuth Flows</h1>
            <h2>
                by
                <a href="https://www.linkedin.com/in/nicolas-vanden-bossche"> Nicolas Vanden Bossche </a>
            </h2>

            <div style="display: flex">
                <div style="width: 80%; float: left">
                    <p>
                        This is a Node.js application with as sole purpose to practice and understand the different
                        OAuth flows for authorization on the Salesforce platform. The goal is to help others on their
                        journey to CTA (Certified Technical Architect) by providing them with a deeper understanding of
                        Identity and Access Management.
                    </p>
                    <p>
                        The navigation bar allows you to go the section of a specific flow. Each section will show you a
                        sequence diagram of that flow. By clicking the "Show/Hide Details" button you can read a more
                        detailed explanation of what is happening in the background. By clicking the "Production" or
                        "Sandbox" buttons, you can launch the authorization flow.
                    </p>
                    <p>
                        This application is based on a template by
                        <a href="https://jitendrazaa.com/"> Jitendra Zaa </a>
                        and inspired by conversations with and diagrams by
                        <a href="https://cloudsundial.com/about-me"> Lawrence Newcombe </a>.
                    </p>
                </div>
                <div style="width: 20%; float: right">
                    <img style="height: inherit" src="Salesforce.png" />
                </div>
            </div>
        </div>

        <!-- User Agent Flow -->
        <div class="jumbotron" id="userAgentFlow">
            <h2>User Agent Flow</h2>
            <figure>
                <img
                    class="authdiagram"
                    src="https://cloudsundial.com/sites/default/files/2020-05/User%20Agent%203000.png"
                />
                <figcaption>User Agent flow diagram - created by Lawrence Newcombe</figcaption>
            </figure>
            <button
                type="button"
                style="margin-right: 40px"
                class="btn btn-info"
                data-toggle="collapse"
                data-target="#userAgentCollapse"
            >
                Show/Hide Details
            </button>

            <div id="userAgentCollapse" class="collapse">
                <ol class="smallFont">
                    <li>
                        This section covers the
                        <a
                            href="https://help.salesforce.com/articleView?id=remoteaccess_oauth_user_agent_flow.htm&type=5&sfdcIFrameOrigin=null"
                        >
                            OAuth 2.0 User-Agent flow</a
                        >
                    </li>
                    <li>
                        Upon clicking the button, the user is redirected with an HTTP GET to the Salesforce
                        Authorization Endpoint (Authorization Server) with the following parameters:
                        <ul>
                            <li>
                                <code>response_type=token</code> OR
                                <code>response_type=token%20id_token</code>
                            </li>
                            <li><code>client_id=<%= clientId %></code> (client ID configured in Connected App)</li>
                            <li>
                                <code>redirect_uri=<%= callbackURL %></code>
                            </li>
                            <li>
                                <code>scope=&lt;Scope parameters&gt;</code> (see
                                <a
                                    href="https://help.salesforce.com/articleView?id=remoteaccess_oauth_tokens_scopes.htm&type=5"
                                >
                                    OAuth Tokens and Scopes
                                </a>
                                )
                            </li>
                            <li>
                                <code>state=&lt;Unique Identifier&gt;</code>
                            </li>
                            <li>
                                <code>nonce=&lt;High Entropy Code&gt;</code>
                            </li>
                        </ul>
                    </li>
                    <li>Salesforce requests the user to log in and authorize the Connected App.</li>
                    <li>
                        After successful authorization, Salesforce redirects to the callback URL (<%= callbackURL %>) if
                        it matches with the redirect_uri specified in the Connected App. It passes along the Access
                        Token in the URL.
                    </li>
                    <li>
                        The callback page parses the returned data
                        <ul>
                            <li><code>token_type=Bearer</code></li>
                            <li><code>access_token=&lt;Access Token&gt;</code></li>
                            <li>
                                <code>id_token=&lt;ID Token&gt;</code> (contains information about the user's identity
                                when specified in the response_type)
                            </li>
                            <li><code>refresh_token=&lt;Refresh Token&gt;</code></li>
                            <li><code>instance_url=<%= baseURL %></code></li>
                            <li><code>id=&lt;Identity URL&gt;</code></li>
                            (where you can retrieve additional user data if not present in ID token)
                            <li>
                                <code>signature=&lt;Signature for Open ID&gt;</code> (client_secret key applied to
                                id:issued_at - optional)
                            </li>
                        </ul>
                    </li>
                    <li>Access token is used to query Salesforce.</li>
                    <li>
                        There are a few important scenarios to keep in mind where malicious actors can be involved:
                        <ol>
                            <li>
                                A malicious app tries to access resources they are not allowed to. This is blocked by
                                the scope parameter of the Connected App. For example, even if the user has the
                                permission to post on chatter through its permissions, the malicious app will not be
                                able to post on chatter if the <code>chatter_api</code> scope wasn't enabled for the
                                Connected App.
                            </li>
                            <li>
                                A malicious app tries to send a user-agent request on behalf of the actual app
                                (Cross-Site Request Forging or CSRF). This is blocked by the state parameter where the
                                actual app sends a unique identifier for every user-agent request. Only if the actual
                                app sees the same state being posted on the callback URL endpoint, it will know that the
                                original request was originated from its context.
                            </li>
                            <li>
                                A malicious app tries to replay a response from the authorisation server that contains
                                an (OpenID) ID token to impact user data. The nonce is used to detect such replay
                                attacks, i.e. two responses with the same nonce should only be processed once. More
                                details
                                <a href="https://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDToken">
                                    here </a
                                >.
                            </li>
                            <li>
                                A malicious, but seemingly harmless app is installed on your phone. It comes with an
                                embedded browser inside the app which is used to launch the User-Agent flow. However,
                                the embedded browser actually captures username and password while typing. This is
                                something very difficult to block and requires educating the user to not type
                                credentials in an embedded browser unless you really trust the app. It's better to work
                                with a Web-Server flow without client secret or assertion where a trusted mobile browser
                                is used for launching the auth flow (see lower).
                            </li>
                        </ol>
                    </li>
                </ol>
            </div>
            <button
                id="userAgentProduction"
                role="button"
                class="btn btn-primary btn-lg"
                onclick="launchFlow('uAgent', false)"
            >
                Production
            </button>
            <button
                id="userAgentSandbox"
                role="button"
                class="btn btn-primary btn-lg"
                onclick="launchFlow('uAgent', true)"
            >
                Sandbox
            </button>
        </div>

        <!-- Web Server Flow -->
        <div class="jumbotron" id="webServer">
            <h2>Web Server Flow</h2>
            <figure>
                <img
                    class="authdiagram"
                    src="https://cloudsundial.com/sites/default/files/2020-06/Web%20Server%202600.png"
                />
                <figcaption>Web Server flow diagram - created by Lawrence Newcombe</figcaption>
            </figure>
            <button
                type="button"
                style="margin-right: 40px"
                class="btn btn-info"
                data-toggle="collapse"
                data-target="#wsintro"
            >
                Show/Hide Details
            </button>

            <div id="wsintro" class="collapse">
                <div>
                    This section covers the
                    <a href="https://help.salesforce.com/articleView?id=remoteaccess_oauth_web_server_flow.htm&type=5"
                        >OAuth 2.0 Web Server flow</a
                    >.
                </div>
                <div>
                    Three scenarios are covered:
                    <ol>
                        <li>
                            Web Server flow with a client secret: when using a secure web server that can store a client
                            secret. You can make the client secret required in the Connected App setup.
                        </li>
                        <li>
                            Web Server flow with a client assertion: when using a secure web server that has a private
                            key to sign the message.
                        </li>
                        <li>
                            Web Server flow without client secret or assertion: when using a client application (browser
                            / mobile app) that uses an external browser for authorization.
                        </li>
                    </ol>
                </div>
            </div>
            <div>
                <h3>Web Server Flow with Client Secret</h3>
                <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#wsclientsecret">
                    Show/Hide Details
                </button>

                <div id="wsclientsecret" class="collapse">
                    <p>
                        This section covers the
                        <a
                            href="https://help.salesforce.com/articleView?id=remoteaccess_oauth_web_server_flow.htm&type=5"
                            >OAuth 2.0 Web Server flow</a
                        >
                        with client secret.
                    </p>
                    <ol class="smallFont">
                        <li>
                            Client application redirects using HTTP GET to the authorization endpoint at
                            <code><%= baseURL %>/services/oauth2/authorize</code>
                            with the following parameters:
                            <ul>
                                <li><code>response_type=code</code></li>
                                <li>
                                    <code>client_id=<%= clientId %></code>
                                    (client ID configured in Connected App)
                                </li>
                                <li>
                                    <code>redirect_uri=<%= callbackURL %></code>
                                </li>
                                <li>
                                    <code>scope=&lt;Scope parameters&gt;</code> (see
                                    <a
                                        href="https://help.salesforce.com/articleView?id=remoteaccess_oauth_tokens_scopes.htm&type=5"
                                    >
                                        OAuth Tokens and Scopes
                                    </a>
                                    )
                                </li>
                                <li>
                                    <code>code_challenge=<%= codeChallenge %></code>
                                </li>
                                <li>
                                    <code>state=&lt;UniqueIdentifier&gt;</code>
                                </li>
                            </ul>
                        </li>
                        <li>
                            Salesforce asks the user to authenticate and then authorize the application. If successful
                            and redirect_uri matches with the Connected App settings, it redirects to the redirect_uri
                            passing along the following parameters
                            <ul>
                                <li>
                                    <code>code=&lt;Authorization Code&gt;</code>
                                </li>
                                <li><code>state=&lt;UniqueIdentifier&gt;</code> (if state in request)</li>
                            </ul>
                        </li>
                        <li>
                            Callback endpoint receives the authorization code and sends it via HTTP POST to the token
                            endpoint at
                            <code><%= baseURL %>/services/oauth2/token</code>
                            with the following parameters:
                            <ul>
                                <li>
                                    <code>grant_type=authorization_code</code>
                                </li>
                                <li><code>client_id=<%= clientId %></code> (from Connected App)</li>
                                <li><code>client_secret=<%= clientSecret %></code> (from Connected App)</li>
                                <li><code>redirect_uri=<%= callbackURL %></code> (from Connected App)</li>
                                <li><code>code=&lt;Authorization Code&gt;</code> (from previous step)</li>
                                <li>
                                    <code>code_verifier=&lt;Code Verifier&gt;</code> (128 bit random string, base64 and
                                    URL encoded)
                                </li>
                            </ul>
                        </li>
                        <li>
                            The authorization code, code verifier, client id, client secret and redirect uri are all
                            checked. After successful authorization, the authorisation server returns the Access Token
                            as a response to the POST messsage.
                        </li>
                        <li>
                            The response to the POST message is then parsed:
                            <ul>
                                <li>
                                    <code>token_type=Bearer</code>
                                </li>
                                <li>
                                    <code>access_token=&lt;Access Token&gt;</code>
                                </li>
                                <li>
                                    <code>id_token=&lt;ID Token&gt;</code> (contains information about the user's
                                    identity when specified in the response_type)
                                </li>
                                <li>
                                    <code>refresh_token=&lt;Refresh Token&gt;</code>
                                </li>
                                <li>
                                    <code>instance_url=<%= baseURL %></code>
                                </li>
                                <li>
                                    <code>id=&lt;Identity URL&gt;</code>
                                </li>
                                <li><code>issued_at=...</code> (datetime at which the access token was issued)</li>
                                <li>
                                    <code>signature=...</code> (client_secret key applied to id:issued_at - optional)
                                </li>
                            </ul>
                        </li>
                        <li>Access token is used to query Salesforce.</li>
                        <li>
                            There are a few important scenarios to keep in mind where malicious actors can be involved:
                            <ol>
                                <li>
                                    A malicious app pretends it's our server. This is blocked because only our server
                                    should have access to the client secret. That's why it's so important that the
                                    client secret can be well-guarded by the server.
                                </li>
                                <li>
                                    A malicious app tries to access resources they are not allowed to. This is blocked
                                    by the scope parameter of the Connected App. For example, even if the user has the
                                    permission to post on chatter through its permissions, the malicious app will not be
                                    able to post on chatter if the <code>chatter_api</code> scope wasn't enabled for the
                                    Connected App.
                                </li>
                                <li>
                                    A malicious app tries to send an authorization request on behalf of the actual app
                                    (Cross-Site Request Forging or CSRF). This is blocked by the state parameter where
                                    the actual app sends a unique identifier for every authorization request. Only if
                                    the actual app sees the same state being posted on the callback URL endpoint, it
                                    will know that the original request was originated from its context.
                                </li>
                                <li>
                                    A malicious app intercepts the authorization code and tries to use it to get an
                                    access token. This is blocked by using the code_challenge parameter in the
                                    authorization request, which is then checked against the code_verifier parameter in
                                    the token request. The code verifier is 128 bytes of random data with high entropy
                                    that's base64url encoded. The code challenge is the base64url encoded SHA256 hash
                                    value of the code verifier.
                                </li>
                            </ol>
                        </li>
                    </ol>
                </div>
                <button
                    id="webServerSecretProduction"
                    role="button"
                    class="btn btn-primary btn-lg"
                    onclick="launchFlow('webServer', false, 'secret')"
                >
                    Production
                </button>
                <button
                    id="webServerSecretSandbox"
                    role="button"
                    class="btn btn-primary btn-lg"
                    onclick="launchFlow('webServer', true, 'secret')"
                >
                    Sandbox
                </button>
            </div>
            <div>
                <h3>Web Server Flow with Client Assertion</h3>
                <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#wsclientassertion">
                    Show/Hide Details
                </button>

                <div id="wsclientassertion" class="collapse">
                    <p>
                        This section covers the
                        <a
                            href="https://help.salesforce.com/articleView?id=remoteaccess_oauth_web_server_flow.htm&type=5"
                            >OAuth 2.0 Web Server flow</a
                        >
                        with client assertion.
                    </p>
                    <ol class="smallFont">
                        <li>
                            Client application redirects using HTTP GET to the authorization endpoint at
                            <code><%= baseURL %>/services/oauth2/authorize</code>
                            with the following parameters:
                            <ul>
                                <li><code>response_type=code</code></li>
                                <li>
                                    <code>client_id=<%= clientId %></code>
                                    (client ID configured in Connected App)
                                </li>
                                <li>
                                    <code>redirect_uri=<%= callbackURL %></code>
                                </li>
                                <li>
                                    <code>scope=&lt;Scope parameters&gt;</code> (see
                                    <a
                                        href="https://help.salesforce.com/articleView?id=remoteaccess_oauth_tokens_scopes.htm&type=5"
                                    >
                                        OAuth Tokens and Scopes
                                    </a>
                                    )
                                </li>
                                <li>
                                    <code>code_challenge=<%= codeChallenge %></code>
                                </li>
                                <li>
                                    <code>state=&lt;UniqueIdentifier&gt;</code>
                                </li>
                            </ul>
                        </li>
                        <li>
                            Salesforce asks the user to authenticate and then authorize the application. If successful
                            and redirect_uri matches with the Connected App settings, it redirects to the redirect_uri
                            passing along the following parameters
                            <ul>
                                <li>
                                    <code>code=&lt;Authorization Code&gt;</code>
                                </li>
                                <li><code>state=&lt;UniqueIdentifier&gt;</code> (if state in request)</li>
                            </ul>
                        </li>
                        <li>
                            Callback endpoint receives the authorization code and sends it via HTTP POST to the token
                            endpoint at
                            <code><%= baseURL %>/services/oauth2/token</code>
                            with the following parameters:
                            <ul>
                                <li>
                                    <code> grant_type=authorization_code </code>
                                </li>
                                <li>
                                    <code>
                                        client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer
                                    </code>
                                </li>
                                <li><code>client_id=<%= clientId %></code> (from Connected App)</li>
                                <li>
                                    <code> client_assertion=... </code> (JWT token containing information about the
                                    client, signed with private key specified in the Connected App)
                                </li>
                                <li><code>redirect_uri=<%= callbackURL %></code> (from Connected App)</li>
                                <li><code>code=&lt;Authorization Code&gt;</code> (from previous step)</li>
                                <li>
                                    <code>code_verifier=&lt;Code Verifier&gt;</code> (128 bit random string, base64 and
                                    URL encoded)
                                </li>
                            </ul>
                        </li>
                        <li>
                            The authorization code, code verifier, client id, client assertion and redirect uri are all
                            checked. After successful authorization, the authorisation server returns the Access Token
                            as a response to the POST messsage.
                        </li>
                        <li>
                            The response to the POST message is then parsed:
                            <ul>
                                <li>
                                    <code>token_type=Bearer</code>
                                </li>
                                <li>
                                    <code>access_token=&lt;Access Token&gt;</code>
                                </li>
                                <li>
                                    <code>id_token=&lt;ID Token&gt;</code> (contains information about the user's
                                    identity when specified in the response_type)
                                </li>
                                <li>
                                    <code>refresh_token=&lt;Refresh Token&gt;</code>
                                </li>
                                <li>
                                    <code>instance_url=<%= baseURL %></code>
                                </li>
                                <li>
                                    <code>id=&lt;Identity URL&gt;</code>
                                </li>
                                <li><code>issued_at=...</code> (datetime at which the access token was issued)</li>
                                <li>
                                    <code>signature=...</code> (client_secret key applied to id:issued_at - optional)
                                </li>
                            </ul>
                        </li>
                        <li>Access token is used to query Salesforce.</li>
                        <li>
                            There are a few important scenarios to keep in mind where malicious actors can be involved:
                            <ol>
                                <li>
                                    A malicious app pretends it's our server. This is blocked because only our server
                                    should have access to the private key. That's why it's so important that the private
                                    key can be well-guarded by the server.
                                </li>
                                <li>
                                    A malicious app tries to access resources they are not allowed to. This is blocked
                                    by the scope parameter of the Connected App. For example, even if the user has the
                                    permission to post on chatter through its permissions, the malicious app will not be
                                    able to post on chatter if the <code>chatter_api</code> scope wasn't enabled for the
                                    Connected App.
                                </li>
                                <li>
                                    A malicious app tries to send an authorization request on behalf of the actual app
                                    (Cross-Site Request Forging or CSRF). This is blocked by the state parameter where
                                    the actual app sends a unique identifier for every authorization request. Only if
                                    the actual app sees the same state being posted on the callback URL endpoint, it
                                    will know that the original request was originated from its context.
                                </li>
                                <li>
                                    A malicious app intercepts the authorization code and tries to use it to get an
                                    access token. This is blocked by using the code_challenge parameter in the
                                    authorization request, which is then checked against the code_verifier parameter in
                                    the token request. The code verifier is 128 bytes of random data with high entropy
                                    that's base64url encoded. The code challenge is the base64url encoded SHA256 hash
                                    value of the code verifier.
                                </li>
                            </ol>
                        </li>
                    </ol>
                </div>
                <button
                    id="webServerAssertionProduction"
                    role="button"
                    class="btn btn-primary btn-lg"
                    onclick="launchFlow('webServer', false, 'assertion')"
                >
                    Production
                </button>
                <button
                    id="webServerAssertionSandbox"
                    role="button"
                    class="btn btn-primary btn-lg"
                    onclick="launchFlow('webServer', true, 'assertion')"
                >
                    Sandbox
                </button>
            </div>
            <div>
                <h3>Web Server Flow without Client Secret or Assertion</h3>
                <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#wsnone">
                    Show/Hide Details
                </button>

                <div id="wsnone" class="collapse">
                    <p>
                        This section covers the
                        <a
                            href="https://help.salesforce.com/articleView?id=remoteaccess_oauth_web_server_flow.htm&type=5"
                            >OAuth 2.0 Web Server flow</a
                        >
                        without client secret client assertion. A use case of this flow can be part of a mobile
                        authentication flow where the native mobile browser is used rather than an embedded browser. A
                        good explanation of this flow can be found
                        <a href="https://auth0.com/blog/oauth-2-best-practices-for-native-apps/">here</a>.
                    </p>
                    <figure>
                        <img class="authdiagram" src="https://cdn.auth0.com/blog/oath2bcp/hoauth-flow.png" />
                        <figcaption>Web Server flow without secret or assertion diagram - created by Auth0</figcaption>
                    </figure>
                    <ol class="smallFont">
                        <li>
                            Client application redirects using HTTP GET to the authorization endpoint at
                            <code><%= baseURL %>/services/oauth2/authorize</code>
                            with the following parameters:
                            <ul>
                                <li><code>response_type=code</code></li>
                                <li>
                                    <code>client_id=<%= clientId %></code>
                                    (client ID configured in Connected App)
                                </li>
                                <li>
                                    <code>redirect_uri=<%= callbackURL %></code>
                                </li>
                                <li>
                                    <code>scope=&lt;Scope parameters&gt;</code> (see
                                    <a
                                        href="https://help.salesforce.com/articleView?id=remoteaccess_oauth_tokens_scopes.htm&type=5"
                                    >
                                        OAuth Tokens and Scopes
                                    </a>
                                    )
                                </li>
                                <li>
                                    <code>code_challenge=<%= codeChallenge %></code>
                                </li>
                                <li>
                                    <code>state=&lt;UniqueIdentifier&gt;</code>
                                </li>
                            </ul>
                        </li>
                        <li>
                            Salesforce asks the user to authenticate and then authorize the application. If successful
                            and redirect_uri matches with the Connected App settings, it redirects to the redirect_uri
                            passing along the following parameters
                            <ul>
                                <li>
                                    <code>code=&lt;Authorization Code&gt;</code>
                                </li>
                                <li><code>state=&lt;UniqueIdentifier&gt;</code> (if state in request)</li>
                            </ul>
                        </li>
                        <li>
                            Callback endpoint receives the authorization code and sends it via HTTP POST to the token
                            endpoint at
                            <code><%= baseURL %>/services/oauth2/token</code>
                            with the following parameters:
                            <ul>
                                <li>
                                    <code> grant_type=authorization_code </code>
                                </li>
                                <li><code>client_id=<%= clientId %></code> (from Connected App)</li>
                                <li><code>redirect_uri=<%= callbackURL %></code> (from Connected App)</li>
                                <li><code>code=&lt;Authorization Code&gt;</code> (from previous step)</li>
                                <li>
                                    <code>code_verifier=&lt;Code Verifier&gt;</code> (128 bit random string, base64 and
                                    URL encoded)
                                </li>
                                <li>
                                    No client secret or assertion. Make sure to uncheck the "Require Secret for Web
                                    Server Flow" flag in the Connected App.
                                </li>
                            </ul>
                        </li>
                        <li>
                            The authorization code, code verifier, client id, and redirect uri are all checked. After
                            successful authorization, the authorisation server returns the Access Token as a response to
                            the POST messsage.
                        </li>
                        <li>
                            The response to the POST message is then parsed:
                            <ul>
                                <li>
                                    <code>token_type=Bearer</code>
                                </li>
                                <li>
                                    <code>access_token=&lt;Access Token&gt;</code>
                                </li>
                                <li>
                                    <code>id_token=&lt;ID Token&gt;</code> (contains information about the user's
                                    identity when specified in the response_type)
                                </li>
                                <li>
                                    <code>refresh_token=&lt;Refresh Token&gt;</code>
                                </li>
                                <li>
                                    <code>instance_url=<%= baseURL %></code>
                                </li>
                                <li>
                                    <code>id=&lt;Identity URL&gt;</code>
                                </li>
                                <li><code>issued_at=...</code> (datetime at which the access token was issued)</li>
                                <li>
                                    <code>signature=...</code> (client_secret key applied to id:issued_at - optional)
                                </li>
                            </ul>
                        </li>
                        <li>Access token is used to query Salesforce.</li>
                        <li>
                            There are a few important scenarios to keep in mind where malicious actors can be involved:
                            <ol>
                                <li>
                                    This flow authenticates based on the callback URL, just like User Agent flow. Unlike
                                    the User Agent flow, we leverage a mobile browser that is not embedded, which
                                    provides additional security to the mobile app user because the mobile app itself
                                    doesn't need to be trusted fully with username and password.
                                </li>
                                <li>
                                    A malicious app tries to access resources they are not allowed to. This is blocked
                                    by the scope parameter of the Connected App. For example, even if the user has the
                                    permission to post on chatter through its permissions, the malicious app will not be
                                    able to post on chatter if the <code>chatter_api</code> scope wasn't enabled for the
                                    Connected App.
                                </li>
                                <li>
                                    A malicious app tries to send an authorization request on behalf of the actual app
                                    (Cross-Site Request Forging or CSRF). This is blocked by the state parameter where
                                    the actual app sends a unique identifier for every authorization request. Only if
                                    the actual app sees the same state being posted on the callback URL endpoint, it
                                    will know that the original request was originated from its context.
                                </li>
                                <li>
                                    A malicious app intercepts the authorization code and tries to use it to get an
                                    access token. This is blocked by using the code_challenge parameter in the
                                    authorization request, which is then checked against the code_verifier parameter in
                                    the token request. The code verifier is 128 bytes of random data with high entropy
                                    that's base64url encoded. The code challenge is the base64url encoded SHA256 hash
                                    value of the code verifier.
                                </li>
                            </ol>
                        </li>
                    </ol>
                </div>

                <button
                    id="webServerNoneProduction"
                    role="button"
                    class="btn btn-primary btn-lg"
                    onclick="launchFlow('webServer', false, 'none')"
                >
                    Production
                </button>
                <button
                    id="webServerNoneSandbox"
                    role="button"
                    class="btn btn-primary btn-lg"
                    onclick="launchFlow('webServer', true, 'none')"
                >
                    Sandbox
                </button>
            </div>
        </div>

        <!-- Refresh Token Flow -->
        <div class="jumbotron" id="refreshToken">
            <div>
                <h2>OAuth 2.0 Refresh Token Flow</h2>
                <figure>
                    <img
                        class="authdiagram"
                        src="https://cloudsundial.com/sites/default/files/2020-05/Refresh%20token%203000.png"
                    />
                    <figcaption>Refresh token flow diagram - created by Lawrence Newcombe</figcaption>
                </figure>
                <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#refreshCollapse">
                    Show/Hide Details
                </button>

                <div id="refreshCollapse" class="collapse">
                    <ol class="smallFont">
                        <li>
                            This section covers the
                            <a
                                href="https://help.salesforce.com/articleView?id=remoteaccess_oauth_refresh_token_flow.htm&type=5"
                            >
                                OAuth 2.0 Refresh Token flow
                            </a>
                            . Refresh Token flow can only be implemented for OAuth flows with user interaction like Web
                            Server flow and User Agent Flow. Flows like JWT and SAML Bearer don't provide a refresh
                            token even if specified in the scope of the Connected App.
                        </li>
                        <li>
                            Upon clicking the button, the system is using the refresh token (stored on the server) to
                            retrieve a new access token. It sends a POST message to the token endpoint with the
                            following parameters:
                            <ul>
                                <li><code>grant_type=refresh_token</code></li>
                                <li><code>client_id=...</code> (client ID of the connected app)</li>
                                <li><code>refresh_token=...</code> (refresh token stored on server)</li>
                                <li><code>client_secret=...</code> (optional)</li>
                                <li><code>client_assertion=...</code> (optional)</li>
                                <li><code> client_assertion_type=... </code> (optional)</li>
                            </ul>
                        </li>
                        <li>
                            Salesforce checks the refresh token and replies to the POST message with an access token:
                            <ul>
                                <li><code>token_type=Bearer</code></li>
                                <li><code>access_token=...</code> (a new access token)</li>
                                <li><code>id=...</code> (identity URL)</li>
                                <li><code>issued_at=...</code> (time since epoch)</li>
                                <li><code>signature=...</code> (only if client secret is specified)</li>
                                <li><code>scope=...</code> (granted scope)</li>
                            </ul>
                        </li>
                        <li>
                            There are a few important scenarios to keep in mind where malicious actors can be involved:
                            <ol>
                                <li>
                                    The refresh token has the same value as user credentials and should be securely
                                    stored. Proper precautions should be taken so that malicious actors cannot access
                                    this refresh token from e.g. a database. In case a refresh token is compromised, you
                                    can always expire it manually from the Salesforce setup menu.
                                </li>
                            </ol>
                        </li>
                    </ol>
                </div>

                <button
                    id="refreshProduction"
                    role="button"
                    class="btn btn-primary btn-lg"
                    onclick="launchFlow('refresh', false)"
                >
                    Production
                </button>
                <button
                    id="refreshSandbox"
                    role="button"
                    class="btn btn-primary btn-lg"
                    onclick="launchFlow('refresh', true)"
                >
                    Sandbox
                </button>
            </div>
        </div>

        <!-- JWT Bearer Assertion Flow -->
        <div class="jumbotron" id="jwt">
            <div>
                <h2>JWT Bearer Assertion OAuth 2.0 Flow</h2>
                <figure>
                    <img
                        class="authdiagram"
                        src="https://cloudsundial.com/sites/default/files/2020-05/JWT%20Bearer%203000.png"
                    />
                    <figcaption>JWT Bearer Assertion flow diagram - created by Lawrence Newcombe</figcaption>
                </figure>
                <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#jwtCollapse">
                    Show/Hide Details
                </button>

                <div id="jwtCollapse" class="collapse">
                    <p>
                        <i class="note">
                            Use
                            <a href="https://jwt.io/"> this tool </a>
                            to debug JSON token generated in Node.js application.
                        </i>
                    </p>

                    <ol class="smallFont">
                        <li>
                            This section covers the
                            <a href="https://help.salesforce.com/articleView?id=remoteaccess_oauth_jwt_flow.htm&type=5">
                                OAuth 2.0 JWT Bearer Token flow </a
                            >.
                        </li>
                        <li>
                            Upon clicking the button, the system is generating a JWT token. The following claims are
                            made inside the token. These claims are then signed.
                            <ul>
                                <li><code>iss</code> (Issuer, containg client ID)</li>
                                <li><code>sub</code> (Subject, containing Salesforce username)</li>
                                <li>
                                    <code>aud</code> (Audience, always https://test.salesforce.com or
                                    https://login.salesforce.com
                                </li>
                                <li><code>exp</code> (Expiration datetime, expressed in seconds after 1/1/1970)</li>
                            </ul>
                        </li>
                        <li>
                            JWT token is then sent to the token endpoint via HTTP POST with the following parameters:
                            <ul>
                                <li>
                                    <code>grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer</code>
                                </li>
                                <li>
                                    <code>assertion=&lt;JWT Token&gt;</code>
                                    base64url(header.body.signature) - signature by private key is authentication
                                </li>
                                <li>
                                    Scope can't be specified, it's always determined in the following way:
                                    <ul>
                                        <li>
                                            If admins pre-authorize (using profile / permission set), scope parameter is
                                            optional. If not specified, all scopes defined in the connected app are
                                            granted.
                                        </li>
                                        <li>
                                            If users can self-authorize, scope is not taken into account. You need to
                                            first use another flow (like User-Agent or Web-Server) to grant explicit
                                            authorization for the scopes you need. This flow needs to return a refresh
                                            token. The scope returned by the JWT flow is the combination of all
                                            previously granted scopes where a refresh token was returned.
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>
                            Salesforce checks the signature and assertion (containing username). Then checks previous
                            authorizations before granting access token. Previous authorizations can be through
                            permission sets or other OAuth flows with refresh tokens.
                        </li>
                        <li>
                            Access token gets returned and callback function processes and stores access token for use.
                            Following parameters are returned:
                            <ul>
                                <li><code>token_type=Bearer</code></li>
                                <li><code>access_token=...</code></li>
                                <li><code>id=...</code> (identity URL)</li>
                                <li><code>id_token=...</code> (identity token - OpenID)</li>
                            </ul>
                        </li>
                        <li>Access token is used to query Salesforce.</li>
                        <li>
                            There are a few important scenarios to keep in mind where malicious actors can be involved:
                            <ol>
                                <li>
                                    A malicious app tries to access resources they are not allowed to. This is blocked
                                    by the scope parameter of the Connected App. For example, even if the user has the
                                    permission to post on chatter through its permissions, the malicious app will not be
                                    able to post on chatter if the <code>chatter_api</code> scope wasn't enabled for the
                                    Connected App.
                                </li>
                                <li>
                                    A malicious app tries to pretend to be the actual app. This is blocked by applying a
                                    signature to the JWT claims that is based on a private key only known by the actual
                                    app. The corresponding public certificate is uploaded in the connected app.
                                </li>
                            </ol>
                        </li>
                    </ol>
                </div>

                <button
                    id="jwtProduction"
                    role="button"
                    class="btn btn-primary btn-lg"
                    onclick="launchFlow('jwt', false)"
                >
                    Production
                </button>
                <button id="jwtSandbox" role="button" class="btn btn-primary btn-lg" onclick="launchFlow('jwt', true)">
                    Sandbox
                </button>
            </div>
        </div>

        <!-- SAML Bearer Assertion Flow -->
        <div class="jumbotron" id="samlBearerAssertion">
            <div>
                <h2>OAuth 2.0 SAML Bearer Assertion Flow</h2>
                <figure>
                    <img
                        class="authdiagram"
                        src="https://cloudsundial.com/sites/default/files/2020-05/SAML%20Bearer%203000.png"
                    />
                    <figcaption>SAML Bearer Token flow diagram - created by Lawrence Newcombe</figcaption>
                </figure>
                <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#samlBearerCollapse">
                    Show/Hide Details
                </button>

                <div id="samlBearerCollapse" class="collapse">
                    <ol class="smallFont">
                        <li>
                            This section covers the
                            <a
                                href="https://help.salesforce.com/articleView?id=remoteaccess_oauth_SAML_bearer_flow.htm&type=5"
                            >
                                OAuth 2.0 SAML Bearer Assertion Flow </a
                            >. This flow relies on the digital signature for authentication and leverages previous
                            authorizations.
                        </li>
                        <li>
                            Upon clicking the button, the system is generating a SAML bearer token (containing client
                            id, audience, name identifier) and POSTs is to the token endpoint using the following
                            parameters:
                            <ul>
                                <li>
                                    <code> grant_type=urn:ietf:params:oauth:grant-type:saml2-bearer </code>
                                </li>
                                <li>
                                    <code> assertion=&lt;base64url(SAML bearer Token)&gt; </code> - signed with private
                                    key corresponding to the certificate uploaded in the Connected App.
                                </li>
                                <li>
                                    Scope can't be specified, it's always determined in the following way:
                                    <ul>
                                        <li>
                                            If admins pre-authorize (using profile / permission set), scope parameter is
                                            optional. If not specified, all scopes defined in the connected app are
                                            granted.
                                        </li>
                                        <li>
                                            If users can self-authorize, scope is not taken into account. You need to
                                            first use another flow (like User-Agent or Web-Server) to grant explicit
                                            authorization for the scopes you need. This flow needs to return a refresh
                                            token. The scope returned by the JWT flow is the combination of all
                                            previously granted scopes where a refresh token was returned.
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>
                            Salesforce checks the signature and assertion (containing user ID). Then checks previous
                            authorizations before granting access token.
                        </li>
                        <li>
                            Access token gets returned and callback function processes and stores access token for use.
                            Following parameters are returned:
                            <ul>
                                <li>
                                    <code> token_type=Bearer </code>
                                </li>
                                <li>
                                    <code> access_token=... </code>
                                </li>
                                <li><code> id=... </code> (identity URL)</li>
                                <li><code> id_token=... </code> (identity token - OpenID)</li>
                            </ul>
                        </li>
                        <li>Access token is used to query Salesforce.</li>
                    </ol>
                </div>

                <!-- Buttons to launch flow -->
                <button
                    id="samlBearerProduction"
                    role="button"
                    class="btn btn-primary btn-lg"
                    onclick="launchFlow('samlBearer', false)"
                >
                    Production
                </button>
                <button
                    id="samlBearerSandbox"
                    role="button"
                    class="btn btn-primary btn-lg"
                    onclick="launchFlow('samlBearer', true)"
                >
                    Sandbox
                </button>
            </div>
        </div>

        <!-- SAML Assertion Flow -->
        <div class="jumbotron" id="samlAssertion">
            <div>
                <h2>SAML Assertion Flow</h2>
                <figure>
                    <img
                        class="authdiagram"
                        src="https://cloudsundial.com/sites/default/files/2020-05/SAML%20Assertion%203000.png"
                    />
                    <figcaption>SAML Assertion Flow diagram - created by Lawrence Newcombe</figcaption>
                </figure>
                <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#samlAssertCollapse">
                    Show/Hide Details
                </button>
                <div id="samlAssertCollapse" class="collapse">
                    <ol class="smallFont">
                        <li>
                            This section covers the
                            <a
                                href="https://help.salesforce.com/articleView?id=remoteaccess_oauth_web_sso_flow.htm&type=5"
                            >
                                SAML Assertion Flow </a
                            >. This flow relies on the trustworthiness of the Identity Provider that is used for SAML
                            SSO in the Salesforce org.
                        </li>
                        <li>
                            To prepare for this flow, we first need to generate a SAML response and store it locally. To
                            do this, take the following actions:
                            <ol>
                                <li>
                                    Set up Single Sign-On for your Salesforce org using
                                    <a href="https://axiomsso.herokuapp.com/SamlIdpHome.action"> Axiom SSO </a> by
                                    following the steps under "Configure".
                                </li>
                                <li>
                                    Navigate to
                                    <a href="https://axiomsso.herokuapp.com/RequestSamlResponse.action">
                                        Axiom SSO SAML Response Requester </a
                                    >. Make sure that the data entered here is an exact match with your Single Sign-On
                                    (SSO) setup in Salesforce and generate the response.
                                </li>
                                <li>
                                    Copy the plain text SAML response and paste it in a file under
                                    './data/axiomSamlAssertion.xml'. Remove any newlines from the file before saving
                                    (e.g. using find-replace).
                                </li>
                                <li>
                                    Note: a SAML assertion is only valid once and only for a limited amount of time.
                                    Using Axiom, there's 60 seconds before your assertion is no longer valid.
                                </li>
                            </ol>
                        </li>
                        <li>
                            Upon clicking the button, the application will take a locally stored SAML response and
                            encode it for sending to Salesforce. It sends a POST message to the token endpoint with the
                            following parameters:
                            <ul>
                                <li>
                                    <code>grant_type=assertion</code>
                                </li>
                                <li>
                                    <code>assertion_type=urn:oasis:names:tc:SAML:2.0:profiles:SSO:browser</code>
                                </li>
                                <li>
                                    <code>
                                        assertion=&lt;XML SAML response, first base64 encoded, then URL encoded&gt;
                                    </code>
                                </li>
                            </ul>
                            Note that in a real-world application, the SAML response would be requested to the Identity
                            Provider at the moment of the user action rather than stored locally. Especially because
                            SAML responses are only valid for a limited amount of time.
                        </li>
                        <li>
                            Salesforce decodes the assertion and checks the SAML response. The validity of the response
                            can be checked manually with the
                            <a href="https://help.salesforce.com/articleView?id=sso_saml_validation.htm&type=5">
                                SAML validator
                            </a>
                            in the Single Sign-On setting of the Salesforce setup. The key parameters that are checked:
                            <ul>
                                <li>
                                    Username or Federation ID is checked against the User object. If there is no match,
                                    the authorization fails except if JIT provisioning was enabled.
                                </li>
                                <li>
                                    Issuer (Identity Provider) and Entity ID (Audience) should be matching with the SSO
                                    setup inside Salesforce.
                                </li>
                                <li>
                                    Recipient should match the My Domain name of the Salesforce instance if present.
                                </li>
                                <li>
                                    Signature of the SAML response should be signed with the certificate provided in the
                                    SSO setup of Salesforce.
                                </li>
                            </ul>
                        </li>
                    </ol>
                </div>

                <!-- Buttons to launch flow -->
                <button
                    id="samlAssertProduction"
                    role="button"
                    class="btn btn-primary btn-lg"
                    onclick="launchFlow('samlAssert', false)"
                >
                    Production
                </button>
                <button
                    id="samlAssertSandbox"
                    role="button"
                    class="btn btn-primary btn-lg"
                    onclick="launchFlow('samlAssert', true)"
                >
                    Sandbox
                </button>
            </div>
        </div>

        <!-- Device Flow -->
        <div class="jumbotron" id="deviceFlow">
            <div>
                <h2>OAuth 2.0 Device Authentication Flow</h2>
                <figure>
                    <img
                        class="authdiagram"
                        src="https://cloudsundial.com/sites/default/files/2020-05/Device%20Authentication%203000.png"
                    />
                    <figcaption>Device Authentication flow diagram - created by Lawrence Newcombe</figcaption>
                </figure>
                <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#deviceCollapse">
                    Show/Hide Details
                </button>

                <div id="deviceCollapse" class="collapse">
                    <ol class="smallFont">
                        <li>Make sure Device Authentication flow is enabled in Connected App</li>
                        <li>
                            Retrieve a device code using HTTP POST from the token endpoint with the following
                            parameters:
                            <ul>
                                <li><code>response_type=device_code</code></li>
                                <li><code>client_id=<%= clientId %></code></li>
                                <li>
                                    <code>scope=&lt;Scope parameters&gt;</code>
                                    (optional - uses scope defined in Connected App if not specified)
                                </li>
                            </ul>
                        </li>
                        <li>
                            Process the response from the POST, containing the following parameters:
                            <ul>
                                <li><code>user_code=...</code> (code to enter on the verification URI)</li>
                                <li>
                                    <code>verification_uri=...</code> (URL that the user needs to open in another
                                    browser)
                                </li>
                                <li><code>device_code=...</code> (device code to identify device)</li>
                                <li><code>interval=...</code> (number of seconds to wait between polls)</li>
                            </ul>
                        </li>
                        <li>Display the user code and authorization URL to the end user on the device.</li>
                        <li>
                            Start polling the token endpoint with the device code. Make sure not to poll more frequently
                            than the interval specified. This is a POST message with the following parameters:
                            <ul>
                                <li><code>grant_type=device</code></li>
                                <li><code>code=...</code> (device code from response)</li>
                                <li><code>client_id=<%= clientId %></code></li>
                            </ul>
                        </li>
                        <li>User enters the user code in a browser by navigating to the authorization URL.</li>
                        <li>
                            Polling returns access_token. Following output parameters:
                            <ul>
                                <li><code>access_token=...</code></li>
                                <li><code>refresh_token=...</code></li>
                                <li><code>token_type=Bearer</code></li>
                                <li>
                                    <code>scope=&lt;Scope parameters&gt;</code>
                                    (optional - uses scope defined in Connected App if not specified)
                                </li>
                                <li>
                                    <code>instance_url=<%= baseURL %></code>
                                </li>
                                <li><code>id=&lt;Identity URL&gt;</code></li>
                                <li><code>issued_at=...</code> (datetime at which the access token was issued)</li>
                                <li>
                                    <code>signature=...</code> (client_secret key applied to id:issued_at - optional)
                                </li>
                            </ul>
                        </li>
                        <li>Access token is used to query Salesforce</li>
                    </ol>
                </div>

                <button
                    id="deviceProduction"
                    role="button"
                    class="btn btn-primary btn-lg"
                    onclick="launchFlow('device', false)"
                >
                    Production
                </button>
                <button
                    id="deviceSandbox"
                    role="button"
                    class="btn btn-primary btn-lg"
                    onclick="launchFlow('device', true)"
                >
                    Sandbox
                </button>
            </div>
        </div>

        <!-- Username / Password Flow -->
        <div class="jumbotron" id="usernamePassword">
            <div>
                <h2>OAuth 2.0 Username-Password Flow</h2>
                <figure>
                    <img
                        class="authdiagram"
                        src="https://cloudsundial.com/sites/default/files/2020-05/Password%203000.png"
                    />
                    <figcaption>Username-Password flow diagram - created by Lawrence Newcombe</figcaption>
                </figure>
                <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#upCollapse">
                    Show/Hide Details
                </button>

                <div id="upCollapse" class="collapse">
                    <ol class="smallFont">
                        <li>
                            This section covers the
                            <a
                                href="https://help.salesforce.com/articleView?id=remoteaccess_oauth_username_password_flow.htm&type=5"
                            >
                                OAuth 2.0 Username-Password flow
                            </a>
                        </li>
                        <li>
                            Enter username and password in the below form. Make sure to paste your security token after
                            the password or to specify login IPs on your user profile. Attention: This is not secure!
                            Don't use critical credentials, instead use a Trailhead Playground!
                        </li>
                        <li>
                            Upon clicking the button, username and password are sent to the token endpoint via POST
                            method, using the following parameters:
                            <ul>
                                <li><code>grant_type=password</code></li>
                                <li><code>client_id=<%= clientId %></code></li>
                                <li><code>username=&lt;Username&gt;</code></li>
                                <li><code>password=&lt;Password&gt;</code></li>
                                <li>
                                    <code>client_secret=<%= clientSecret %></code>
                                </li>
                            </ul>
                        </li>

                        <li>Salesforce checks the username, password, client ID and client secret.</li>
                        <li>
                            Access token gets returned and callback function processes and stores access token for use.
                            Following parameters are returned:
                            <ul>
                                <li><code>token_type=Bearer</code></li>
                                <li><code>access_token=&lt;Access Token&gt;</code></li>
                                <li>
                                    <code>instance_url=<%= baseURL %></code>
                                </li>
                                <li><code>id=&lt;Identity URL&gt;</code></li>
                                <li><code>issued_at=...</code> (datetime at which the access token was issued)</li>
                                <li>
                                    <code>signature=...</code> (client_secret key applied to id:issued_at - optional)
                                </li>
                            </ul>
                        </li>
                        <li>Access token is used to query Salesforce.</li>
                        <li>
                            There are a few important scenarios to keep in mind where malicious actors can be involved:
                            <ol>
                                <li>
                                    A malicious actor monitors web traffic and can read username and password in plain
                                    text. This actor then abuses the credentials for malicious purposes.
                                </li>
                            </ol>
                        </li>
                    </ol>
                </div>

                <form action="/uPwd" method="POST" name="usernamepasswordFlow">
                    <div class="form-group">
                        <label for="sfdcUsername">Salesforce Username </label>
                        <input
                            class="form-control"
                            name="sfdcUsername"
                            id="sfdcUsername"
                            type="text"
                            value="<%= username %>"
                        />

                        <label for="sfdcPassword">Salesforce Password </label>
                        <input class="form-control" name="sfdcPassword" id="sfdcPassword" type="password" value="" />
                        <br />
                        <button class="btn btn-primary btn-lg" type="submit" name="isSandbox" value="false">
                            Production
                        </button>
                        <button class="btn btn-primary btn-lg" type="submit" name="isSandbox" value="true">
                            Sandbox
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </body>
</html>
